(def sgpref "bar")
(def bejaedn {
:lang :beja-arteiga
:schemata { 									
	  :conjClass [:Prefix, :Suffix] 		
	  :gender [:Common, :Fem, :Masc]
	  }
:morphemes {
  :PRO {:gloss "Pronoun", :pos :Pronoun}
  :SUBJMARK {:gloss "Subject Marker", }
}
:lexemes {
  :dbl {:conjClass :Prefix, :gloss "collect, gather", :pos :Verb, :rootClass :CCC}
  :dgy {:conjClass :Prefix, :gloss "hear", :pos :Verb, :rootClass :CCY}
}
:lxterms #{
   {:label "beja_H-VPrefAffCCYPres"
    :common {:conjClass :Prefix,
	    :lexeme :dgy,
	    :polarity :Affirmative,
	    :pos :Verb,
	    :rootClass :CCY,
	    :tam :Present}
    :terms [[:gender, :number, :person, :token]  ;; schema
	    [:Masc, :Singular, :Person3, "dangì"],
	    [:Common, :Plural, :Person1, "ni-déeg"],
	    [:Common, :Plural, :Person2, "ti-deeg-`na"],
	    [:Masc, :Singular, :Person2, "dangii-`a"],
	    [:Common, :Plural, :Person3, "?i-deeg-`na"],
	    [:Common, :Singular, :Person1, "?a-dangì"],
	    [:Fem, :Singular, :Person3, "dangì"],
	    [:Fem, :Singular, :Person2, "dangii-`"]]
    }
    {:label "beja_H-VPrefAffCCYAor"
    :common {:conjClass :Prefix,
	    :lexeme :dgy,
	    :polarity :Affirmative,
	    :pos :Verb,
	    :rootClass :CCY,
	    :tam :Aorist}
    :terms [[:gender, :number, :person, :token]  ;; schema
	    [:Common, :Plural, :Person3, "?i-diig-`na"],
	    [:Common, :Plural, :Person2, "ti-diig-`na"],
	    [:Fem, :Singular, :Person2, "ti-diig-`i"],
	    [:Common, :Plural, :Person1, "ni-dìig"],
	    [:Masc, :Singular, :Person3, "?i-dìig"],
	    [:Fem, :Singular, :Person3, "ti-dìig"],
	    [:Masc, :Singular, :Person2, "ti-diig-`a"],
	    [:Common, :Singular, :Person1, "?a-dìig"]]
    }
    }
})

(def lang (name (bejaedn :lang)))
(def Lang (clojure.string/capitalize lang))
(format "aama:%s a aamas:Language ." Lang)
(format  "aama:%s rdfs:label \"%s\" ." Lang Lang)

(def schemata (bejaedn :schemata))
(doseq [[property valuelist] schemata]
(def prop (name property))
;; NB clojure.string/capitalize gives  wrong output with 
;; terms like conjClass: =>Conjclass rather than ConjClass
(def Prop (clojure.string/capitalize prop))
(def x ( map println [
(format "%s:%s aamas:lang aama:%s ." sgpref prop Lang)
(format "%s:%s aamas:lang aama:%s ." sgpref Prop Lang)
(format "%s:%s rdfs:domain aamas:Term ." sgpref prop)
(format "%s:%s rdfs:label \"%s exponents\" ." sgpref Prop prop)
(format "%s:%s rdfs:label \"%s\" ." sgpref prop prop)
(format "%s:%s rdfs:range %s:%s ." sgpref prop sgpref Prop)
(format "%s:%s rdfs:subClassOf %s:MuExponent ." sgpref Prop sgpref)
(format "%s:%s rdfs:subPropertyOf %s:muProperty ." sgpref prop sgpref )
]))
(doall  x)
(def vallist valuelist)
(doseq [value vallist] 
(def valname (name value))
(def y ( map println [
(format "%s:%s aamas:lang aama:%s ." sgpref valname Lang)
(format "%s:%s rdf:type %s:%s ." sgpref valname Lang Prop)
(format "%s:%s rdfs:label \"%s\"." sgpref valname valname)]))
(doall y))
)

(def morphemes (bejaedn :morphemes))
(doseq [[morpheme featurelist] morphemes]
(def morph (name morpheme))
(def x ( map println [
(format "aama:%s-%s a aamas:Muterm ;" Lang morph)
(format "\taamas:lang aama:%s ;" Lang)
(format "\trdfs:label \"%s\" ;" morph)
]))
(doall  x)
(doseq [[feature value] featurelist] 
(def mprop (name feature))
(def mval (name value))
(if 
	(= mprop "gloss")
	(def y ( map println [
		(format "\trdfs:comment \"%s\" ;" mval)]))
	(def y ( map println [
		(format "\t%s:%s %s:%s ;" sgpref mprop sgpref mval)]))
)
(doall y)
)
(println "\t.")
)

(def lexemes (bejaedn :lexemes))
(doseq [[lexeme featurelist] lexemes]
(def lex (name lexeme))
(def x ( map println [
(format "aama:%s-%s a aamas:Lexeme ;" Lang lex)
(format "\taamas:lang aama:%s ;" Lang)
(format "\trdfs:label \"%s\" ;" lex)
]))
(doall  x)
(doseq [[feature value] featurelist] 
(def lprop (name feature))
(def lval (name value))
(if 
	(= lprop "gloss")
	(def y ( map println [
		(format "\taamas:%s \"%s\" ;" lprop lval)]))
	(def y ( map println [
		(format "\t%s:%s %s:%s ;" sgpref lprop sgpref lval)]))
)
(doall y)
)
(println "\t.")
)

+++++++++++++WORK IN PROGRESS++++++++++++++++

:lxterms #{
    {:label "beja_H-VPrefAffCCYPres"
    :common {:conjClass :Prefix,
	    :lexeme :dgy,
	    :polarity :Affirmative,
	    :pos :Verb,
	    :rootClass :CCY,
	    :tam :Present}
    :terms [[:gender, :number, :person, :token]  ;; schema
	    [:Masc, :Singular, :Person3, "dangì"],
	    [:Common, :Plural, :Person1, "ni-déeg"],
	    [:Common, :Plural, :Person2, "ti-deeg-`na"],
	    [:Masc, :Singular, :Person2, "dangii-`a"],
	    [:Common, :Plural, :Person3, "?i-deeg-`na"],
	    [:Common, :Singular, :Person1, "?a-dangì"],
	    [:Fem, :Singular, :Person3, "dangì"],
	    [:Fem, :Singular, :Person2, "dangii-`"]]
    }
======================================
(def lexterms (bejaedn :lxterms))
(doseq [ termcluster lexterms]
	(def label (:label termcluster))
	(def z (map println [
	(format "aama:ID%s a aamas:Term ;" label)
	(format "\taamas:lang aama:%s ;" Lang)]))
	(doall z)
	(def common (:common termcluster))
	;; Need to build up string which can then be println-ed with each term of cluster
	(doseq [[feature value] common]
		(def tprop (name feature))
		(def tval (name value))
			(def x ( map println [
				(if (= tprop "lexeme")
					(format "\taamas:%s aama:%s-%s ;" tprop Lang tval)
					(format "\t%s:%s %s:%s ;" sgpref tprop sgpref tval)
				)
				])
			)
		(doall x)
	)
	(def terms (:terms termcluster))
	(doseq [term terms]
		(def y (map println [
			(format "\t %s" term)]))
		(doall y)
	)
)

;; Start with terms 1
(def lexterms (bejaedn :lxterms))
(doseq [ termcluster lexterms]
(def x (map println [
	(format "\n\t %s" "TERMCLUSTER")]))
(doall x)
(def terms (:terms termcluster))
(def schema (first terms))
(def data (next terms))
(doseq [term data]
(def y (map println [
	(format "\t %s" "SCHEMA")
	(format "\t %s" schema)	
	(format "\t %s" "DATA")
	(format "\t %s" term)
	]))
(doall y))
)

;; Start with terms 2
(def lexterms (bejaedn :lxterms))
(doseq [ termcluster lexterms]
	(def x (map println [
		(format "\n\t %s" "TERMCLUSTER")]))
	(doall x)
	(def terms (:terms termcluster))
	(def schema (first terms))
	(def data (next terms))
	(def common (:common termcluster))
	;; Need to build up string which can then be println-ed with each term of cluster
	(def label (:label termcluster))
	(doseq [term data]
		(def w (map println [
			(format "aama:UUID%s a aamas:Term ;" label)
			(format "\taamas:lang aama:%s ;" Lang)]))
		(doall w)
		(doseq [[feature value] common]
			(def tprop (name feature))
			(def tval (name value))
				(def x ( map println [
					(if (= tprop "lexeme")
						(format "\taamas:%s aama:%s-%s ;" tprop Lang tval)
						(format "\t%s:%s %s:%s ;" sgpref tprop sgpref tval)
					)
					])
				)
			(doall x)
		)
		(def termmap (apply assoc {}
			(interleave schema term)))
		(doseq [tpropval termmap]
			(def tprop (name (key tpropval)))
			(def tval (name (val tpropval)))
			(def y (map println [
				(if (= tprop "token")
					(format "\t%s:%s \"%s\" ;" sgpref tprop tval )
					(format "\t%s:%s %s:%s ;" sgpref tprop sgpref tval )	
				)
				]))
			(doall y)
		)
		(def z (map println [
			(format "\t." )]))
		(doall z)
	)
)

(if 
	(= tprop "lexeme")
	(def x ( map println [
		(format "\taamas:%s aama:%s-%s ;" tprop Lang tval)]))
	(def x ( map println [
		(format "\t%s:%s %s:%s ;" sgpref tprop sgpref tval)]))
)




		(def y (map println [
		;	(format "\t %s" "SCHEMA")
			(format "\t %s" schema)	
		;	(format "\t %s" "DATA")
			(format "\t %s" term)
			]))

(map vector schema term)
(map list schema term)

;Original:
(doseq [[tprops  tvals] terms]
(def y (map println [
	(format "props: %s" tprops)
	(format "values: %s" tvals)]))
(doall y))

(doseq [[tprops]  terms]
(def y (map println [
	(format "props: %s" tprops)]))
(doall y))

(def terms (:terms lexterms))
(def schema (first terms))
(def data (next terms))
(doseq [tvals data]
(def tvals (first data))
(def y (map println [
	(format "schema: %s" schema)
	(format "data: %s" data)]))
(doall y))

(apply assoc {}
	(interleave [:gender, :number, :person, :token] 
	    [:Masc, :Singular, :Person3, "dangì"]))
;; Following works (given def of schema and tvals)
(apply assoc {}
	(interleave schema
	    tvals))))
;; Following gives "Wrong number of ags (0) passed to: PersistentArrayMap"
(def schema (first terms))
(def data (next terms))
(doseq [tvals  data]
(def tvals (first data))
(def y (		
(apply assoc {}
	(interleave schema
	    tvals))))
(doall y))

;; Following work:
(map vector schema tvals)
(map list schema tvals)
;; Following gives "ClassCastException clojure.lang.LazySeq cannot be cast to clojure.lang.IFn"
(doseq [tvals  data]
(def tvals (first data))
(def y (		
(apply map
	vector schema
	    tvals))))
(doall y))
;;Following gives "NullPointerException user/eval1449 (NO_SOURCE_FILE:4)
(doseq [tvals  data]
(def tvals (first data))
(def y (		
(println "The vector is: " (map vector schema tvals))))
;(doall y)
;(def data (next data))
;(def tvals (first data))
)

(def schema (first terms))
(def data (next terms))
(doseq [tvals  data]
(def tvals (first data))
(def z (	
		(for [x schema] 
		(def y ([x tvals]))
( map println [
		(format "\t%s:%s %s:%s ;" sgpref x sgpref y)])))
(doall z))


(def schema (first terms))
(def data (next terms))
(doseq [tvals  data]
(def tvals (first data))
(def y (		
(map vector schema
	    tvals)))
(doall y))


(def schema (first terms))
(def data (next (first terms)))
(apply assoc {}
	(interleave schema 
	    data))
		
		
++++++++++++++++VARIA+++++++++++++++++++++++		
;; Term-cluster print-out
(def lexterms (bejaedn :lxterms))
(doseq [ termcluster lexterms]
(def label (:label termcluster))
(def common (:common termcluster))
(def terms (:terms termcluster))
(println (str "\nThe termcluster: " label " has the common features: \n\n"common " \n\nand the terms: \n\n" terms "\n")))

(def lex (name lexeme))
(def x ( map println [
(format "aama:%s-%s a aamas:Lexeme ;" Lang lex)
(format "\taamas:lang aama:%s ;" Lang)
(format "\trdfs:label \"%s\" ;" lex)
]))
(doall  x)
(doseq [[feature value] featurelist] 
(def lprop (name feature))
(def lval (name value))
(if 
	(= lprop "gloss")
	(def y ( map println [
		(format "\taamas:%s \"%s\" ;" lprop lval)]))
	(def y ( map println [
		(format "\t%s:%s %s:%s ;" sgpref lprop sgpref lval)]))
)
(doall y)
)
(println "\t.")
)

;; Following work (given def of schema and term)
(def schema [:gender, :number, :person, :token])
(def term [:Masc, :Singular, :Person3, "dangì"])
(apply assoc {} (interleave schema term))
(map vector schema term)
(map list schema term)


